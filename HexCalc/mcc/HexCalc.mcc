//----------------------------------------------------------
//	hexcalc Microcode (c) 2021-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//----------------------------------------------------------
			.code 7, 50, hexcalc_code.mif, hexcalc_code.cgf, hexcalc_code.coe, hxc:hexcalc_code.vhd, hexcalc_code.hex, hexcalc_code.bin, 8;
			.mapper 8, 7, hexcalc_map.mif, hexcalc_map.cgf, hexcalc_map.coe, hxc:hexcalc_map.vhd, hexcalc_map.hex, hexcalc_map.bin, 1;
			.controller hexcalc_control_unit.vhd, 4;
			.symbol 7, 256, hexcalc_sym.mif, hexcalc_sym.cgf, hexcalc_sym.coe, hxc:hexcalc_sym.vhd, hexcalc_sym.hex, hexcalc_sym.bin, 32;

// System interface signals
MT_CTRL			.valfield 2 values 
				nop,
				on,
				off,
				clear default nop;
				
MT_ROW			.valfield 4 values * default 0;
MT_COL			.valfield 4 values * default 0;

//d_value			.valfield MT_ROW values * default 0;
//c_value			.valfield MT_COL values * default 0;

bitcnt			.regfield 2 values
				same,
				load,	// from MT_COL		
				max,	// 31 or 15	
				dec
				default same;
				
// Component interface signals
STATUS			.valfield 2 values
				ready,	// waiting for input character
				done,	// input processed, will go ready on next clock cycle
				busy,	// processing
				busy_using_mt default busy;	// processing and needing the MT_8816
				
// RXD_READY	load input register on low to high transition

// Serial UART sender interface signals
// CHAR			8-bit ASCII or 0x00 if no char is to be sent
// TXDREADY		sender is ready

seq_cond:		.if 4 values 
				true, 			// hard-code to 1
				input_is_zero,	// do not process 0x00 input char
				TRACE_ERROR,
				TRACE_CHAR,
				TXDREADY,
				TXDSEND,
				bitcnt_is_zero,
				loopcnt_is_zero,
				d_flag_is_set,
				c_flag_is_set,
				z_flagand_is_set,
				button,
				z_flagtos_is_set,
				z_flagnos_is_set,
				cond_14,
				false			// hard-code to 0
				default true;
seq_then:	.then 7 values next, repeat, return, fork, @ default next;				// any label
seq_else:	.else 7 values next, repeat, return, fork, 0b0000000..0b1111111, @ default next;	// any value as it can be a trace char
			
// contains ASCII char for UART trasmit
TXDCHAR		.regfield 4 values 
				same,
				char_space,
				char_cr,
				char_lf,
				char_E,			// 'E' in "ERR"
				char_R,			// 'R' in "ERR"
				char_EQU,		// '='
				char_I,			// 'I'
				char_zero,		// 0x00
				// use bit 4 to lookup using HEX2ASCII table
				inp0,			// input character LSN
				inp1,			// input character MSN
				-,
				-,
				-,
				-,
				errcode
				default same;
				
opr 			.valfield 3 values
				np_np_np,
				np_np_ld,	// only effects 0xC[onstant] and 0xD[ata]
				m2_d2_d2,
				np_m2_m2,
				d2_d2_d2,
				d2_d2_np,	// used for multiplication
				np_d2_d2,
				m2_m2_np default np_np_np;
				
//	error codes are 1 to 2, 0 means no error
errcode:		.regfield 2 values
				ok, 
				err_badchar,			// ERR1
				err_divzero,			// ERR2
				same
				default same;

d_flag:			.regfield 2 values	// delay flag
				same,
				column,
				zero,
				one default same;

c_flag:			.regfield 2 values	// carry flag
				same,
				adder,
				zero,
				one default same;

z_flags:		.regfield 2 values	// zero flags, one per row. Initialize with set all to 1!
				same,
				update,
				-,
				set default same;
				
loopcnt			.regfield 2 values
				same,
				-,			
				max,	// 31 or 15	
				dec
				default same;
				
// placeholder
dummy:			.valfield 1 values * default 0;
						
//	useful aliases, these are evaluated as simple text replacement of label with everything between .alias and ; 
goto:		.alias if false then next else;
noop:		.alias if true then next else next;
back:	    .alias if true then return else return;
data:		.alias opr = np_np_ld, MT_ROW = 0b0000, MT_COL =;
const:		.alias opr = np_np_ld, MT_COL = 0b0000, MT_ROW =;
load_bitcnt:.alias bitcnt <= load, MT_COL =;
wait:		.alias if button then next else repeat;


// switches in the matrix
nuke		.alias STATUS = busy_using_mt, MT_CTRL = clear;
connect:	.alias STATUS = busy_using_mt, MT_CTRL = on,;
disconnect: .alias STATUS = busy_using_mt, MT_CTRL = off,;
to:			.alias ,;
from:		.alias ,;

row_tos:	.alias MT_ROW = 0;
row_nos:	.alias MT_ROW = 1;
row_a:		.alias MT_ROW = 0;
row_q:		.alias MT_ROW = 1;
row_r2:		.alias MT_ROW = 2;
row_r3:		.alias MT_ROW = 3;
row_r4:		.alias MT_ROW = 4;
row_r5:		.alias MT_ROW = 5;
row_r6:		.alias MT_ROW = 6;
row_r7:		.alias MT_ROW = 7;
row_m:		.alias MT_ROW = 7;
row_delay:	.alias MT_ROW = 8;
row_not:	.alias MT_ROW = 9;
row_and:	.alias MT_ROW = 0xA;
row_sum:	.alias MT_ROW = 0xB;
row_const:	.alias MT_ROW = 0xC;
row_direct:	.alias MT_ROW = 0xD;
row_14:		.alias MT_ROW = 0xE;
row_15:		.alias MT_ROW = 0xF;

col_tos:	.alias MT_COL = 0;
col_nos:	.alias MT_COL = 1;
col_a:		.alias MT_COL = 0;
col_q:		.alias MT_COL = 1;
col_r2:		.alias MT_COL = 2;
col_r3:		.alias MT_COL = 3;
col_r4:		.alias MT_COL = 4;
col_r5:		.alias MT_COL = 5;
col_r6:		.alias MT_COL = 6;
col_r7:		.alias MT_COL = 7;
col_m:		.alias MT_COL = 7;
col_delay:	.alias MT_COL = 8;
col_not:	.alias MT_COL = 9;
col_10:		.alias MT_COL = 0xA;
col_11:		.alias MT_COL = 0xB;
col_adc1:	.alias MT_COL = 0xC;
col_adc2:	.alias MT_COL = 0xD;
col_and1:	.alias MT_COL = 0xE;
col_and2:	.alias MT_COL = 0xF;

// gosub definitions - this works because "jump" pushes return address to stack if both then/else are same
emit:		.sub TXDCHAR;
print_crlf:	.sub;	
trace:		.sub;	
matrix_nop:	.sub;
matrix_nop1:.sub;
matrix_push:.sub;
matrix_swap:.sub;
matrix_pop:	.sub;
matrix_push:.sub;
div2:		.sub bitcnt;
prep_regs:	.sub loopcnt;
a_pm_m:		.sub c_flag;	// A <= A + M | A - M

// other
reset:		.alias MT_CTRL = clear, errcode <= ok;

			.org 0;
//	First 4 microcode locations can't be used branch destinations
//	---------------------------------------------------------------------------
_reset:		reset;  

_reset1:	reset;

_reset2:	reset;

_reset3:	reset;

//	indicate availability and wait for start signal
//	---------------------------------------------------------------------------
deadloop:	STATUS = ready, if input_is_zero then repeat else next;
			trace();
			if true then fork else fork;	// jump to entry point per character code (see .map statements below)

			.map 0b????????;
badchar:	errcode <= err_badchar, if TRACE_ERROR then printerror else nextchar;	// ERR1
divzero:	errcode <= err_divzero, if TRACE_ERROR then printerror else nextchar;	// ERR2	
printerror:	emit(char_E);		// ERR
			emit(char_R);
			emit(char_R);
			emit(errcode);
			emit(char_space);
			emit(inp1);			// FF hex code of offending char
			emit(inp0);			// FF hex code of offending char
			print_crlf();

			.map 0;
			.map 0x09;	// treat tabs and spaces same way (ignore them)	
			.map ' ';
nextchar:	STATUS = done, goto deadloop;
					
			// TOS <=> NOS
			.map 's';
			.map 'S';
swap:		nuke, matrix_swap();
			goto exec;
			
			// nuke all registers and error code
			.map 'n';
			.map 'N';
			errcode <= ok, nuke, goto exec;

			// clear all registers
			.map 'z';	
			.map 'Z';
			errcode <= ok, nuke, matrix_nop1();	// no switch on TOS means pull down, so it 0
exec:		z_flags <= set, div2(max);				// 16 or 32 *
			goto nextchar;		

			// TOS <= TOS + NOS, POP
			.map '+';
plus:		c_flag <= zero, nuke, matrix_pop();
			connect row_nos to col_adc2;
pm:			connect row_sum to col_tos;
			connect row_tos to col_adc1, goto exec;
			
			// TOS <= TOS - NOS, POP
			.map '-';
minus:		c_flag <= one, nuke, matrix_pop();
			connect row_nos to col_not;
			connect row_not to col_adc2, goto pm;
			
			// unsigned division
			.map '/';
div:		prep_regs(max);
			if z_flagtos_is_set then divzero;
			// A < Q < 0
div_loop:	disconnect row_q from col_q;
			d_flag <= zero, connect row_delay to col_q;
			connect row_q to col_a;
			STATUS = busy_using_mt, opr = m2_m2_np;
			disconnect row_delay from col_q;
			disconnect row_q from col_a;
			connect row_q to col_q; 
			//wait;
			
			// A <= A - M
			connect row_m to col_not;
			connect row_not to col_adc2, a_pm_m(one);
			
			disconnect row_not from col_adc2, if c_flag_is_set then next else restore_a;

			// Q(0) <= 1
			connect row_a to col_a;
			disconnect row_q from col_q;
			connect row_q to col_delay;
			connect row_delay to col_q;
			STATUS = busy_using_mt, opr = d2_d2_np;
			d_flag <= one;
			STATUS = busy_using_mt, opr = m2_m2_np;
			nuke, matrix_nop();

div_next:	if loopcnt_is_zero then swap;	// quotient on TOS, remainder on NOS
			loopcnt <= dec, goto div_loop;
			
			// A <= A + M, Q(0) <= 0
restore_a:	connect row_m to col_adc2, a_pm_m(zero);
			disconnect row_m from col_adc2, goto div_next;
			
			// TOS, NOS <= TOS * NOS, R(7) destroyed
//			.map '*';
//mul:		loopcnt <= max, prep_regs();
//			if z_flagnos_is_set then nextchar; // we already have TOS, NOS = 0
//			// NOS(0) to d_flag
//m_loop:		connect row_nos to col_delay;
//			STATUS = busy_using_mt, opr = np_d2_d2, d_flag <= column;
//			STATUS = busy_using_mt, opr = np_m2_m2;
//			c_flag <= zero, disconnect row_nos from col_delay, if d_flag_is_set then m_add_r7 else m_shift0;
			
			// C,TOS <= TOS + R7 + 0
//m_add_r7:	connect row_r7 to col_adc1;
//m_add:		connect row_tos to col_adc2;
//			bitcnt <= max, connect row_sum to col_tos, div2();
//			disconnect row_sum from col_tos, if c_flag_is_set then m_shift1;

			// c_flag >> TOS >> NOS
//m_shift0:	d_flag <= zero, connect row_tos to col_nos, goto m_shift;
//m_shift1:	d_flag <= one, connect row_tos to col_nos;
//m_shift:	connect row_delay to col_tos;
//			disconnect row_nos from col_nos, opr = d2_d2_np;

			// reset connections and iterate
//			disconnect row_tos from col_nos;
//			disconnect row_delay from col_tos;
//			connect row_nos to col_nos, if loopcnt_is_zero then nextchar;
//			loopcnt <= dec, goto m_loop;	// do it 16 or 32 times
			
			// enter: push all down, TOS <= 0
			.map 0x0D;
enter:		nuke, matrix_push();
			goto exec;
			
			// load digits to stack top (R0), note digits are in reverse bit order
			.map '0';
			data 0b0000, goto hexchar;

			.map '1';
			data 0b1000, goto hexchar;

			.map '2';
			data 0b0100, goto hexchar;

			.map '3';
			data 0b1100, goto hexchar;

			.map '4';
			data 0b0010, goto hexchar;

			.map '5';
			data 0b1010, goto hexchar;

			.map '6';
			data 0b0110, goto hexchar;

			.map '7';
			data 0b1110, goto hexchar;

			.map '8';
			data 0b0001, goto hexchar;

			.map '9';
			data 0b1001, goto hexchar;

			.map 'a';
			.map 'A';
			data 0b0101, goto hexchar;

			.map 'b';
			.map 'B';
			data 0b1101, goto hexchar;

			.map 'c';
			.map 'C';
			data 0b0011, goto hexchar;

			.map 'd';
			.map 'D';
			data 0b1011, goto hexchar;

			.map 'e';
			.map 'E';
			data 0b0111, goto hexchar;

			.map 'f';
			.map 'F';
			data 0b1111;
hexchar:	nuke, matrix_nop1();
			load_bitcnt 3;
			connect row_direct to col_tos;
			STATUS = busy_using_mt, opr = m2_d2_d2, bitcnt <= dec, if bitcnt_is_zero then next else repeat;
			load_bitcnt 3;
			STATUS = busy_using_mt, opr = np_m2_m2, bitcnt <= dec, if bitcnt_is_zero then nextchar else repeat;
			
// subroutines (keep in mind max stack call level is 4!)
a_pm_m:		connect row_a to col_adc1;
			connect row_sum to col_a, z_flags <= set, div2(max);
			disconnect row_sum from col_a, back;
			//wait;
			//back;

prep_regs:	nuke, matrix_nop1();
			// set up registers
			disconnect row_r7 from col_r7;
			connect row_tos to col_r7, z_flags <= set, div2(max);	// R7 <= TOS, TOS <= 0
			connect row_r7 to col_r7;
			disconnect row_tos from col_r7, back;		

// rotate all registers right (LSB first) through switch matrix;
div2:		STATUS = busy_using_mt, opr = d2_d2_d2, c_flag <= adder, z_flags <= update, if bitcnt_is_zero then return;
			bitcnt <= dec, goto div2;
			
// swap TOS and NOS
matrix_swap:connect row_tos to col_nos;
			connect row_nos to col_tos, goto matrix_nop;

// set the diagonal switches for R2..R7, which means after shift up or down these regs will be the same
matrix_nop1:connect row_nos to col_nos;
matrix_nop: connect row_r2 to col_r2;	
			connect row_r3 to col_r3;	
			connect row_r4 to col_r4;	
			connect row_r5 to col_r5;	
			connect row_r6 to col_r6;	
			connect row_r7 to col_r7, back;	
			
// push all towards R7, TOS is 0, R7 is lost
matrix_push:connect row_tos to col_nos;	// R0 <= R1;
			connect row_nos to col_r2;	// R1 <= R0;
			connect row_r2 to col_r3;	
			connect row_r3 to col_r4;	
			connect row_r4 to col_r5;	
			connect row_r5 to col_r6;	
			connect row_r6 to col_r7, back;	

// pop all towards R0, TOS is result of operation, R7 is 0
matrix_pop:	connect row_r2 to col_nos;
			connect row_r3 to col_r2;
			connect row_r4 to col_r3;
			connect row_r5 to col_r4;
			connect row_r6 to col_r5;
			connect row_r7 to col_r6, back;
			
trace:		if TRACE_CHAR then next else return;
//			emit(char_I);		// I=<received char>
//			emit(char_EQU);
			emit(inp1);			
			emit(inp0);

print_crlf: emit(char_cr);
			TXDCHAR <= char_lf;

emit:		if TXDREADY then next else repeat;	// sync with baudrate clock that drives UART
//			if TXDREADY then next else repeat;
			if TXDREADY then next else repeat;
			if TXDSEND then return else return;	// generate a send pulse for UART sender	
			
/// -- junk --
			// Q(0) <= 1
//			connect row_a to col_a;
//			connect row_direct to col_q;
			
//			connect row_a to col_a;
//			disconnect row_q from col_q;
//			connect row_q to col_delay;
//			connect row_delay to col_q;
//			STATUS = busy_using_mt, opr = d2_d2_np;
//			d_flag <= one;
//			STATUS = busy_using_mt, opr = m2_m2_np;
//			disconnect row_a from col_a;
//			disconnect row_delay from col_q;
//			wait;
//			goto div_next;

			// Q(0) <= 1
//			connect row_q to col_q;
//			connect row_direct to col_q;
//			connect row_a to col_a;
//			wait;
//			data 0b0001, z_flags <= set, div2(max);
//			disconnect row_a from col_a;
//			disconnect row_direct from col_q;
//			wait;
//			goto div_next;