_reset: c_flag <= zero, d_flag <_reset1: c_flag <= zero, d_flag _reset2: c_flag <= zero, d_flag _reset3: c_flag <= zero, d_flag deadloop: STATUS = ready, if inpecho(input);                    if true then fork else fork;    badchar: errcode <= err_badchar,divzero: errcode <= err_divzero,printerror: emit(char_E);       emit(char_R);                   emit(char_R);                   emit(errcode);                  emit(char_space);               emit(inp1);                     emit(inp0);                     print_crlf();                   nextchar: STATUS = done, if falsenter: STATUS = busy_using_mt, Mif false then next else exec;   dup();                          if false then next else done;   rotate: STATUS = busy_using_mt, r7_to_tos: STATUS = busy_using_mswap: STATUS = busy_using_mt, MTif false then next else exec;   shift_down();                   if false then next else done;   shift_up();                     if false then next else done;   dup();                          shift_down();                   if z_flagtos_is_set then next elSTATUS = busy_using_mt, MT_CTRL if false then next else exec;   root: STATUS = busy_using_mt, MTSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL heron_step();                   root_loop: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL if c_flag_is_set then next else STATUS = busy_using_mt, MT_CTRL root_cont: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL heron_step();                   if false then next else root_looc_flag <= zero, d_flag <= zero, c_flag <= zero, d_flag <= zero, exec: div2(max, set);           done: print_st();               if false then next else nextcharplus: c_flag <= zero, STATUS = badd: STATUS = busy_using_mt, MT_pm: STATUS = busy_using_mt, MT_CSTATUS = busy_using_mt, MT_CTRL minus: c_flag <= one, STATUS = bSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL divmod(zero);                   if false then next else swap;   mul: prep_regs(max);            if z_flagnos_is_set then done;  m_loop: STATUS = busy_using_mt, STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npc_flag <= zero, STATUS = busy_usm_add_r7: STATUS = busy_using_mtm_add: STATUS = busy_using_mt, MSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL m_shift0: d_flag <= zero, STATUSm_shift1: d_flag <= one, STATUS m_shift: STATUS = busy_using_mt,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL loopcnt <= dec, if false then neSTATUS = busy_using_mt, MT_CTRL div2(max, set);                 bitcnt <= max, if z_flagtos_is_sbitcnt_s0: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = d2STATUS = busy_using_mt, MT_CTRL loopcnt <= max;                 loopcnt <= inc;                 loopcnt_s0: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL loopcnt_d0: STATUS = busy_using_if loopcnt_nibble then next elseif d_flag_is_set then next else bcd_adjust(one);                loopcnt_n0: if loopcnt_is_zero tif bitcnt_is_zero then conv_donebitcnt <= dec, if false then nexconv_done0: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bitcnt <= max, if z_flagtos_is_sbitcnt_s1: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL loopcnt <= max;                 loopcnt <= inc;                 loopcnt_s1: c_flag <= one, opr =STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL loopcnt_d1: STATUS = busy_using_if loopcnt_nibble then next elseif c_flag_is_set then next else if bitcnt_is_zero then loopcnt_nSTATUS = busy_using_mt, MT_CTRL bcd_adjust(zero);               loopcnt_n1: if loopcnt_is_zero tif bitcnt_is_zero then conv_donebitcnt <= dec, if false then nexconv_done1: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL opr = np_np_ld, MT_COL = 0b0000,opr = np_np_ld, MT_COL = 0b1101,opr = np_np_ld, MT_COL = 0b1111,opr = np_np_ld, MT_COL = 0b1001;hexchar: bitcnt <= load, MT_COL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bitcnt <= dec;                  bitcnt <= dec;                  bitcnt <= dec;                  STATUS = busy_using_mt, opr = npdivmod: prep_regs(max);         if z_flagtos_is_set then next elif d_flag_is_set then swap else div_loop: STATUS = busy_using_mtd_flag <= zero, STATUS = busy_usSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = d2d_flag <= one;                  STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL div_next: if loopcnt_is_zero theloopcnt <= dec, if false then nerestore_a: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL a_pm_m: STATUS = busy_using_mt, STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL prep_regs: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL heron_step: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL divmod(same);                   STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL shift_down: prep_shift();       shift_dloop: STATUS = busy_usingbitcnt <= dec, if false then nexshift_up: prep_shift();         shift_uloop: STATUS = busy_usingbitcnt <= dec, if false then nexprep_shift: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL dup: STATUS = busy_using_mt, MT_STATUS = busy_using_mt, MT_CTRL div2: STATUS = busy_using_mt, opbitcnt <= dec, if false then nexmatrix_swap: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL matrix_nop1: STATUS = busy_usingmatrix_nop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_push: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_pop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bcd_adjust: STATUS = busy_using_STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL opr = np_np_ld, MT_COL = 3, if cbcd_sub3: STATUS = busy_using_mtSTATUS = busy_using_mt, MT_CTRL bcd_add3: STATUS = busy_using_mtbcd_3: STATUS = busy_using_mt, MSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL print_st: loopcnt <= max, if TRAloopcnt <= inc, print_crlf();   st_loop: selreg = internal, emitst_loop1: loopcnt <= inc;       if loopcnt_nibble then next elseif loopcnt_is_zero then print_crecho: if TRACE_INPUT then emit eprint_crlf: emit(char_cr);      TXDCHAR <= char_lf;             emit: if TXDSEND then next else if TXDREADY then next else repeaif TXDREADY then next else repeaemit0: TXDCHAR <= char_zero, if 