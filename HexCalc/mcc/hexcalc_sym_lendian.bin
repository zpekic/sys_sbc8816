_reset: MT_CTRL = clear, errcode_reset1: MT_CTRL = clear, errcod_reset2: MT_CTRL = clear, errcod_reset3: MT_CTRL = clear, errcoddeadloop: STATUS = ready, if inptrace();                        if true then fork else fork;    badchar: errcode <= err_badchar,printerror: emit(char_E);       emit(char_R);                   emit(char_R);                   emit(errcode);                  emit(char_space);               emit(inp1);                     emit(inp0);                     print_crlf();                   nextchar: STATUS = done, if falsSTATUS = busy_using_mt, MT_CTRL if false then next else exec;   errcode <= ok, STATUS = busy_usierrcode <= ok, STATUS = busy_usiexec: z_flags <= set, bitcnt <= if false then next else nextchardiv: loopcnt <= max, prep_regs()div_loop: d_flag <= zero, STATUSSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2c_flag <= one, STATUS = busy_usiSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL opr = np_np_ld, MT_ROW = 0b0000,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL if false then next else div_nextrestore_a: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL c_flag <= zero, STATUS = busy_usdiv_next: loopcnt <= dec, STATUSif loopcnt_is_zero then nextcharmul: loopcnt <= max, prep_regs()m_loop: STATUS = busy_using_mt, STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npc_flag <= zero, STATUS = busy_usm_add_r7: STATUS = busy_using_mtm_add: STATUS = busy_using_mt, Mbitcnt <= max, STATUS = busy_usiSTATUS = busy_using_mt, MT_CTRL m_shift0: d_flag <= zero, STATUSm_shift1: d_flag <= one, STATUS m_shift: STATUS = busy_using_mt,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL loopcnt <= dec, if false then neenter: STATUS = busy_using_mt, Mif false then next else exec;   opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,opr = np_np_ld, MT_ROW = 0b0000,hexchar: STATUS = busy_using_mt,bitcnt <= load, MT_COL = 3;     STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2bitcnt <= load, MT_COL = 3;     STATUS = busy_using_mt, opr = npprep_regs: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL bitcnt <= max, STATUS = busy_usiSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL div2: STATUS = busy_using_mt, opbitcnt <= dec, if false then nexmatrix_swap: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL matrix_nop1: STATUS = busy_usingmatrix_nop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_push: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_pop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL trace: if TRACE_CHAR then next eemit(inp1);                     emit(inp0);                     print_crlf: emit(char_cr);      TXDCHAR <= char_lf;             emit: if TXDREADY then next elseif TXDREADY then next else repeaif TXDREADY then next else repeaif TXDSEND then return else retu                                                                                                                                                                