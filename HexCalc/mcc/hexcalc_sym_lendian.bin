_reset: MT_CTRL = clear, errcode_reset1: MT_CTRL = clear, errcod_reset2: MT_CTRL = clear, errcod_reset3: MT_CTRL = clear, errcoddeadloop: STATUS = ready, if inpif true then fork else fork;    badchar: errcode <= err_badchar,divzero: errcode <= err_divzero,printerror: emit(char_E);       emit(char_R);                   emit(char_R);                   emit(errcode);                  emit(char_space);               emit(inp1);                     emit(inp0);                     print_crlf();                   echo(input);                    nextchar: STATUS = done, if falsecho(input);                    enter: STATUS = busy_using_mt, Mif false then next else exec;   echo(input);                    dup: STATUS = busy_using_mt, MT_STATUS = busy_using_mt, MT_CTRL echo(input);                    rotate: STATUS = busy_using_mt, STATUS = busy_using_mt, MT_CTRL echo(input);                    swap: STATUS = busy_using_mt, MTif false then next else exec;   prep_shift();                   lsr_loop: STATUS = busy_using_mtbitcnt <= dec, if false then nexprep_shift();                   lsl_loop: STATUS = busy_using_mtbitcnt <= dec, if false then nexecho(input);                    errcode <= ok, STATUS = busy_usiecho(input);                    errcode <= ok, STATUS = busy_usiexec: div2(max, set);           done: print_st();               if false then next else nextcharecho(input);                    plus: c_flag <= zero, STATUS = badd: STATUS = busy_using_mt, MT_pm: STATUS = busy_using_mt, MT_CSTATUS = busy_using_mt, MT_CTRL echo(input);                    minus: c_flag <= one, STATUS = bSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL echo(input);                    div: prep_regs(max);            if z_flagtos_is_set then divzerodiv_loop: STATUS = busy_using_mtd_flag <= zero, STATUS = busy_usSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = d2d_flag <= one;                  STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL div_next: if loopcnt_is_zero theloopcnt <= dec, if false then nerestore_a: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL echo(input);                    mul: prep_regs(max);            if z_flagnos_is_set then done;  m_loop: STATUS = busy_using_mt, STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npc_flag <= zero, STATUS = busy_usm_add_r7: STATUS = busy_using_mtm_add: STATUS = busy_using_mt, MSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL m_shift0: d_flag <= zero, STATUSm_shift1: d_flag <= one, STATUS m_shift: STATUS = busy_using_mt,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL loopcnt <= dec, if false then neecho(input);                    STATUS = busy_using_mt, MT_CTRL div2(max, set);                 bitcnt <= max, if z_flagtos_is_sbitcnt_s0: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = d2STATUS = busy_using_mt, MT_CTRL loopcnt <= max;                 loopcnt <= inc;                 loopcnt_s0: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npif d_flag_is_set then next else bcd_adjust(one);                loopcnt_n0: if loopcnt_is_zero tif bitcnt_is_zero then conv_donebitcnt <= dec, if false then nexconv_done0: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL echo(input);                    STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bitcnt <= max, if z_flagtos_is_sbitcnt_s1: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL if true then next else next;    STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL loopcnt <= max;                 loopcnt <= inc;                 loopcnt_s1: c_flag <= one, opr =STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npif c_flag_is_set then next else if bitcnt_is_zero then loopcnt_nSTATUS = busy_using_mt, MT_CTRL bcd_adjust(zero);               loopcnt_n1: if loopcnt_is_zero tif bitcnt_is_zero then conv_donebitcnt <= dec, if false then nexconv_done1: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL opr = np_np_ld, MT_COL = 0b0000,opr = np_np_ld, MT_COL = 0b1101,opr = np_np_ld, MT_COL = 0b1111,opr = np_np_ld, MT_COL = 0b1001;hexchar: echo(input);           bitcnt <= load, MT_COL = 3, c_flSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bitcnt <= dec;                  bitcnt <= dec;                  bitcnt <= dec;                  STATUS = busy_using_mt, opr = npa_pm_m: STATUS = busy_using_mt, STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL prep_regs: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL prep_shift: echo(input);        lsr: STATUS = busy_using_mt, MT_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL d_flag <= zero, bitcnt <= max, zdiv2: STATUS = busy_using_mt, opbitcnt <= dec, if false then nexmatrix_swap: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL matrix_nop1: STATUS = busy_usingmatrix_nop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_push: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_pop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bcd_adjust: STATUS = busy_using_STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL opr = np_np_ld, MT_COL = 3, if cbcd_sub3: STATUS = busy_using_mtSTATUS = busy_using_mt, MT_CTRL bcd_add3: STATUS = busy_using_mtbcd_3: STATUS = busy_using_mt, MSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL print_st: loopcnt <= max, if TRAloopcnt <= inc, print_crlf();   st_loop: selreg = internal, emitloopcnt <= inc;                 loopcnt <= inc;                 loopcnt <= inc;                 loopcnt <= inc;                 if loopcnt_is_zero then print_crecho: if TRACE_INPUT then emit eprint_crlf: emit(char_cr);      TXDCHAR <= char_lf;             emit: if TXDSEND then next else if TXDREADY then next else repeaif TXDREADY then next else repeaTXDCHAR <= char_zero, if true th                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                