_reset: MT_CTRL = clear, errcode_reset1: MT_CTRL = clear, errcod_reset2: MT_CTRL = clear, errcod_reset3: MT_CTRL = clear, errcoddeadloop: STATUS = ready, if inpif true then fork else fork;    badchar: errcode <= err_badchar,divzero: errcode <= err_divzero,printerror: emit(char_E);       emit(char_R);                   emit(char_R);                   emit(errcode);                  emit(char_space);               emit(inp1);                     emit(inp0);                     print_crlf();                   echo(input);                    nextchar: STATUS = done, if falsecho(input);                    enter: STATUS = busy_using_mt, Mif false then next else exec;   echo(input);                    dup: STATUS = busy_using_mt, MT_STATUS = busy_using_mt, MT_CTRL echo(input);                    rotate: STATUS = busy_using_mt, STATUS = busy_using_mt, MT_CTRL echo(input);                    swap: STATUS = busy_using_mt, MTif false then next else exec;   echo(input);                    errcode <= ok, STATUS = busy_usiecho(input);                    errcode <= ok, STATUS = busy_usiexec: z_flags <= set, div2(max);done: print_st();               if false then next else nextcharecho(input);                    plus: c_flag <= zero, STATUS = badd: STATUS = busy_using_mt, MT_pm: STATUS = busy_using_mt, MT_CSTATUS = busy_using_mt, MT_CTRL echo(input);                    minus: c_flag <= one, STATUS = bSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL echo(input);                    div: prep_regs(max);            if z_flagtos_is_set then divzerodiv_loop: STATUS = busy_using_mtd_flag <= zero, STATUS = busy_usSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = d2d_flag <= one;                  STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL div_next: if loopcnt_is_zero theloopcnt <= dec, if false then nerestore_a: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL echo(input);                    mul: prep_regs(max);            if z_flagnos_is_set then done;  m_loop: STATUS = busy_using_mt, STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npc_flag <= zero, STATUS = busy_usm_add_r7: STATUS = busy_using_mtm_add: STATUS = busy_using_mt, MSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL m_shift0: d_flag <= zero, STATUSm_shift1: d_flag <= one, STATUS m_shift: STATUS = busy_using_mt,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL loopcnt <= dec, if false then neecho(input);                    STATUS = busy_using_mt, MT_CTRL div2(max);                      bitcnt <= max;                  bitcnt_s: STATUS = busy_using_mtSTATUS = busy_using_mt, MT_CTRL if true then next else next;    STATUS = busy_using_mt, opr = d2STATUS = busy_using_mt, MT_CTRL loopcnt <= max;                 loopcnt <= inc;                 loopcnt_s: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL if true then next else next;    STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npif d_flag_is_set then next else STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL c_flag <= one, opr = np_np_ld, Mif true then next else next;    STATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, opr = npSTATUS = busy_using_mt, MT_CTRL if true then next else next;    loopcnt_n: if loopcnt_is_zero thif bitcnt_is_zero then conv_donebitcnt <= dec, if false then nexconv_done: STATUS = busy_using_mdiv2(max);                      if false then next else done;   opr = np_np_ld, MT_COL = 0b0000,opr = np_np_ld, MT_COL = 0b1101,opr = np_np_ld, MT_COL = 0b1111,opr = np_np_ld, MT_COL = 0b1001;hexchar: echo(input);           bitcnt <= load, MT_COL = 3, c_flSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bitcnt <= dec;                  bitcnt <= dec;                  bitcnt <= dec;                  STATUS = busy_using_mt, opr = npa_pm_m: STATUS = busy_using_mt, STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL prep_regs: STATUS = busy_using_mSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL div2: STATUS = busy_using_mt, opbitcnt <= dec, if false then nexmatrix_swap: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL matrix_nop1: STATUS = busy_usingmatrix_nop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_push: STATUS = busy_usingSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL matrix_pop: STATUS = busy_using_STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL print_st: loopcnt <= max, if TRAloopcnt <= inc, print_crlf();   st_loop: selreg = internal, emitloopcnt <= inc;                 loopcnt <= inc;                 loopcnt <= inc;                 loopcnt <= inc;                 if loopcnt_is_zero then print_crecho: if TRACE_INPUT then emit eprint_crlf: emit(char_cr);      TXDCHAR <= char_lf;             emit: if TXDREADY then next elseif TXDSEND then return else repebcd_add: c_flag <= zero, loopcntloopcnt <= inc;                 bcd_loop: STATUS = busy_using_mtSTATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL bcd_digadd: STATUS = busy_using_STATUS = busy_using_mt, opr = d2STATUS = busy_using_mt, opr = d2STATUS = busy_using_mt, opr = d2if daa_flag_is_set then next elsbcd_daa: STATUS = busy_using_mt,STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, opr = m2STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL STATUS = busy_using_mt, MT_CTRL c_flag <= zero, opr = np_np_ld, STATUS = busy_using_mt, opr = d2opr = np_np_ld, MT_COL = 1;     STATUS = busy_using_mt, opr = d2opr = np_np_ld, MT_COL = 1;     STATUS = busy_using_mt, opr = d2opr = np_np_ld, MT_COL = 0;     STATUS = busy_using_mt, opr = d2c_flag <= one;                  next_digit: if loopcnt_is_zero t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if false then next else divzero;